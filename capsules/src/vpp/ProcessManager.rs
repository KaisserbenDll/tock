//! Implementation of VPP Process Management dedicated Functions
//! This module VppProcessManager can be used as a component to control and "inspect"
//! userspace processes.

#![allow(unused_imports)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(dead_code)]

use core::cell::Cell;
use core::cmp;
use core::str;
use crate::vpp::mloi::*;
use kernel::Kernel;
use kernel::procs::ProcessType;
use kernel::capabilities::ProcessManagementCapability;
use kernel::debug;
use crate::vpp::process;
use crate::vpp::process::VppProcess;

const NUM_PROCS: usize = 4 ; // Number of allowed vpp processes.
// This should always eqaul number of tock processes.

pub struct VppProcessManager <C: ProcessManagementCapability>{
    vpp_processes: [Option<VppProcess>;NUM_PROCS],
    kernel: &'static Kernel,
    capability: C,
    /// Variable that retrieves the last error generated by a Process
    /// used in _mk_Get_Error
    last_error: Cell<MK_ERROR_e>
}

impl <C: ProcessManagementCapability> VppProcessManager<C> {
    pub fn new(kernel: &'static Kernel, capability : C) -> VppProcessManager<C> {

        let tockprocesses = kernel.processes;
        let mut vppprocesses:[Option<VppProcess>;NUM_PROCS] = Default::default();
        debug!("Length is {}",tockprocesses.len());
        for i in 0..tockprocesses.len() {
            let proc = Some(process::VppProcess::create_vpp_process(tockprocesses[i]));
            vppprocesses[i] = proc;
        }
        VppProcessManager {
            vpp_processes: vppprocesses,
            kernel,
            capability,
            last_error: Cell::new(MK_ERROR_e::MK_ERROR_NONE)
        }
    }

    pub  fn _mk_Get_Error(&self) {
        debug!("The last error is  {:?}", self.last_error.get())
    }


    pub fn get_process_ref_interal(&self, handle: MK_HANDLE_t) -> Option<&VppProcess> {
        // Mapping id to handle. For the time being,
        // we consider the handle as the id but in 32 bits. This will probably be changed later.
        let id = convert_to_id(handle);

        self.vpp_processes.iter().find_map(|proc| {
            if proc.as_ref().unwrap().get_vpp_id() == id {
                // even if id found, the Process must not be in "DEAD" state
                if proc.as_ref().unwrap().get_vpp_state() == VppState::DEAD {
                    self.last_error.set(MK_ERROR_e::MK_ERROR_UNKNOWN_ID);
                    None
                }
                // if the Process in any other state, a pointer to
                // that process is delivered with a success flag
                else {
                    self.last_error.set(MK_ERROR_e::MK_ERROR_NONE) ;
                    proc.as_ref()
                }
                // if the id was not found, Unknow ID error is raised.
            } else {
                self.last_error.set(MK_ERROR_e::MK_ERROR_UNKNOWN_ID) ;
                None
            }
        })
    }

    pub (crate)  fn _mk_get_process_handle(& self, _eProcess_ID: MK_Process_ID_u)
                                           -> MK_HANDLE_t {
        let handle = convert_to_handle(_eProcess_ID);
        let process =self.get_process_ref_interal(handle);
        if process.is_some() {handle}  else { 0}
        // there is a problem when returning 0 as a handle. This might be in fact
        // the id of another handle. Whether, a Process ID as 0 is not allowed
        // or wrap this with an Option.
    }

    // Concerning Priorities there is another missing function that needs to be implemented.
    // Based on the index of Tock Processes, Vpp Priorities are mapped accordingly.

    pub (crate) fn _mk_get_process_priority(& self, _hProcess: MK_HANDLE_t) -> MK_PROCESS_PRIORITY_e {
        let process = self.get_process_ref_interal(_hProcess);
        if process.is_some(){
            let prio = process.unwrap().get_vpp_priority();
            debug!("Process Priority is {:?}", prio );
            prio
        }
        else {
            //self.last_error.set(MK_ERROR_UNKNOWN_HANDLE);
            MK_PROCESS_PRIORITY_e::MK_PROCESS_PRIORITY_ERROR

        }
    }


    pub (crate) fn _mk_set_process_priority(&self, _hProcess: MK_HANDLE_t,
                                            _xPriority: MK_PROCESS_PRIORITY_e) -> MK_ERROR_e {

        // Check for UNKNOWN_PRIORITY by figuring out the encoding of the enum in rust
        // Check for the value _xPriority if different from those 4 values
        // TO-DO

        let process =self.get_process_ref_interal(_hProcess);
        if process.is_some() {
            process.unwrap().set_vpp_priority(_xPriority);
            debug!("Process Priority set to {:?}",_xPriority );
            debug!("Process priority is {:?}",process.unwrap().get_vpp_priority());

            MK_ERROR_e::MK_ERROR_NONE
        } else {
            MK_ERROR_e::MK_ERROR_UNKNOWN_HANDLE
        }

        // TO DO
        // Depending of the Scheduler Type, this can be implemented as follows:
        // Based on the index on the PROCESSES Array, priorities can be defined
        // index 0: MK_PROCESS_PRIORITY_HIGH
        // index 1: MK_PROCESS_PRIORITY_NORMAL
        // index 2: MK_PROCESS_PRIORITY_LOW
        // match _xPriority {
        //     // check for the index of the PROCESSES ARRAY and change accordingly
        //     MK_PROCESS_PRIORITY_e::MK_PROCESS_PRIORITY_LOW => {
        //         // _hProcess.tockprocess.appid.index changes
        //     }
        //     MK_PROCESS_PRIORITY_e::MK_PROCESS_PRIORITY_NORMAL => {
        //     }
        //     MK_PROCESS_PRIORITY_e::MK_PROCESS_PRIORITY_HIGH => {
        //     }
        //     MK_PROCESS_PRIORITY_e::MK_PROCESS_PRIORITY_ERROR => {
        //         MK_ERROR_UNKNOWN_PRIORITY
        //         // Is this the right use case ?
        //     }
        // }

    }
    pub (crate) fn _mk_suspend_process(&self, mut _hProcess: MK_HANDLE_t) -> MK_ERROR_e {
        let vppprocess = self.get_process_ref_interal(_hProcess);
        if vppprocess.is_some() {
            let process = vppprocess.unwrap();
            debug!("Vpp Process State before suspending {:?}", process.get_vpp_state());
            // Suspend Vpp Process State
            process.suspend_vpp_process();
            debug!("Vpp Process State after suspending {:?}", process.get_vpp_state());
            // Suspend Tock Process State
            self.kernel.process_each_capability(
                &self.capability,
                |proc| {
                    let vppproc_name = process.tockprocess.unwrap().get_process_name();
                    if vppproc_name ==   proc.get_process_name() {
                        process.tockprocess.unwrap().stop();
                        debug!("Tock Process {} Suspended", vppproc_name);
                    }
                }
            );
            MK_ERROR_e::MK_ERROR_NONE
        } else {
            MK_ERROR_e::MK_ERROR_UNKNOWN_HANDLE
        }
    }

    pub (crate) fn _mk_resume_process(&self, mut _hProcess: MK_HANDLE_t) -> MK_ERROR_e {
        let vppprocess = self.get_process_ref_interal(_hProcess);
        if vppprocess.is_some() {
            let process = vppprocess.unwrap();
            debug!("Vpp Process State before resuming {:?}", process.get_vpp_state());
            // Resume Vpp Process State
            process.resume_vpp_process();
            debug!("Vpp Process State after resuming {:?}", process.get_vpp_state());

            // Resume Tock Process State
            self.kernel.process_each_capability(
                &self.capability,
                |proc| {
                    let vppproc_name = process.tockprocess.unwrap().get_process_name();
                    if vppproc_name ==   proc.get_process_name() {
                        process.tockprocess.unwrap().resume();
                        debug!("Tock Process {} Resumed", vppproc_name);
                    }
                }
            );
            MK_ERROR_e::MK_ERROR_NONE
        } else {
            MK_ERROR_e::MK_ERROR_UNKNOWN_HANDLE
        }

    }

}

